<?php

namespace WikiGods\AdditionalTestAssertions\Traits;

use Illuminate\Broadcasting\Channel;
use Illuminate\Broadcasting\PresenceChannel;
use Illuminate\Broadcasting\PrivateChannel;
use Illuminate\Contracts\Broadcasting\ShouldBroadcast;
use Illuminate\Support\Str;

trait AdditionalTestAssertions
{
    /**
     * Assert that a class uses a trait.
     */
    protected function assertClassUsesTrait($class, $traitClass): void
    {
        $modelName = class_basename($class);
        $traitName = class_basename($traitClass);

        $this->assertContains(
            $traitClass,
            class_uses($class),
            "The class {$modelName} does not use {$traitName}."
        );
    }

    /**
     * Assert that a model has a UUID as a primary key.
     */
    protected function assertHasUuid($model, $exception = null): void
    {

        $class = class_basename($model);

        if ($exception){
            if (($exception->getCode() == 'HY000' || $exception->getCode() == 0) && Str::contains($exception->getMessage(), 'datatype mismatch')) {
                $this->fail(
                    "The getKeyName: {$model->getKeyName()} of the {$model->getTable()} table is not UUID. Example: \$table->uuid('{$model->getKeyName()}')->primary();"
                );
            }
        }else{
            $this->assertTrue(
                Str::isUuid($model->{$model->getKeyName()}),
                "The identifier '{$model->getKeyName()}' of the {$class} model must be uuid."
            );
        }
    }

    /**
     * Assert that a model defines the expected attribute casts.
     */
    protected function assertCasts($casts, $model): void
    {
        $this->assertEquals(
            $casts,
            ($model)->getCasts()
        );
    }

    /**
     * Assert that a model defines the expected attribute appends.
     */
    protected function assertAppends($appends, $model): void
    {
        $this->assertEquals(
            $appends,
            ($model)->getAppends()
        );
    }

    /**
     * Assert that an event does not broadcast to the current user.
     */
    protected function assertDontBroadcastToCurrentUser($event, $socketId = 'socket-id'): void
    {
        $this->assertInstanceOf(ShouldBroadcast::class, $event);

        $this->assertEquals(
            $socketId, // Generated by Broadcast::shouldReceive('socket')->andReturn('socket-id');
            $event->socket,
            'The event ' . get_class($event) . ' must call the method "dontBroadcastToCurrentUser" in the constructor.'
        );
    }

    /**
     * Assert the type of broadcast channel (public, private, presence).
     */
    protected function assertEventChannelType($channelType, $event): void
    {
        $types = [
            'public' => Channel::class,
            'private' => PrivateChannel::class,
            'presence' => PresenceChannel::class,
        ];

        if (!Str::contains($channelType, array_keys($types))) {
            $this->fail("The channel type '{$channelType}' is not valid. Valid types are: " . implode(', ', array_keys($types)));
        }

        $this->assertEquals(
            $types[$channelType],
            get_class($event->broadcastOn())
        );
    }

    /**
     * Assert the name of the broadcast channel.
     */
    protected function assertEventChannelName($channelName, $event): void
    {
        $this->assertEquals(
            $channelName,
            $event->broadcastOn()->name
        );
    }

    /**
     * Assert that a relationship is of type "hasOne" and the related model matches.
     */
    protected function assertHasOne($model, $relationship): void
    {
        $this->assertInstanceOf(
            $model,
            $relationship,
            'The hasOne relationship is not an instance of the model ' . basename($model)
        );

    }

    /**
     * Assert that a relationship is of the type "belongsTo" and the related model matches.
     */
    protected function assertBelongsTo($model, $relationship): void
    {
        $this->assertInstanceOf(
            $model,
            $relationship,
            'The belongsTo relationship is not an instance of the model ' . basename($model)
        );
    }

    /**
     * Assert that a relationship is of type "belongsToMany" and the related model matches.
     * Optionally, assert the count of related models.
     */
    protected function assertBelongsToMany($model, $relationship, $count): void
    {
        $this->assertInstanceOf(
            $model,
            $relationship ? $relationship->first() : null,
            'The belongsToMany relationship is not an instance of the model ' . basename($model)
        );

        if ($count){
            $this->assertCount($count, $relationship);
        }
    }

    /**
     * Assert that a relationship is of the type "hasMany" and the related model matches.
     * Optionally, assert the count of related models.
     */
    protected function assertHasMany($model, $relationship): void
    {
        $this->assertInstanceOf(
            $model,
            $relationship ? $relationship->first() : null,
            'The hasMany relationship is not an instance of the model ' . basename($model)
        );
    }

    /**
     * Assert that a relationship is of type "hasManyThrough" and the related model matches.
     */
    protected function assertHasOneThrough($model, $relationship): void
    {
        $this->assertInstanceOf(
            $model,
            $relationship,
            'The hasOneThrough relationship is not an instance of the model ' . basename($model)
        );
    }

    /**
     * Assert that a relationship is of type "hasManyThrough" and the related model matches.
     */
    protected function assertHasManyThrough($model, $relationship, $key = 'laravel_through_key'): void
    {
        $relationshipOrNull = $relationship ? $relationship->first() : null;

        $this->assertInstanceOf(
            $model,
            $relationshipOrNull,
            'The hasManyThrough relationship is not an instance of the model ' . basename($model)
        );

        if (!Str::contains($relationshipOrNull, $key)){

            $this->fail("Key not found '{$key}' ");
        }
    }
}